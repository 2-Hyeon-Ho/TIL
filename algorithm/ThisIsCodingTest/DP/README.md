다이나믹 프로그래밍(Dynamic Programming) DP : 메모리 공간을 약간 더 사용하면서 연산 속도를 비약적으로 증가시킬 수 있는 방법  
DP를 사용할 수 있는 경우  
1. 큰 문제를 작은 문제로 나눌 수 있다.  
2. 작은 문제에서 구한 정답은 그것을 포함한 큰 문제에서도 동일하다. 

대표문제 : 피보나치 수열  

메모제이션 기법 : 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로. 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면   
메모한 결과를 그대로 가져오는 기법  => 탑다운 방식에 국한되어 있다.  

다이나믹 프로그래밍의 전형적인 형태는 바텀-업 방식이다.

--------------------------------------------------------------------------------------------------------------------------------  

DP를 활용한 재귀피보나치수열  
기존의 피보나치수열을 재귀함수를 이용하여 풀이할 때는 동일한 함수가 반복적으로 호출되어 시간복잡도가 증가되었다.   
![img.png](img.png)  
위의 그림처럼 중복된 노드를 방문하게 되어 효율적이지 못하다.  
시간복잡도는 O(2^N)이다.

메모제이션 기법을 활용하여 풀이를 하면 이미 구했던 답을 저장해두고 필요하면 다시 쓸 수 있기 때문에 시간복잡도를 줄일 수 있다.  
![img_1.png](img_1.png)  
이와 같이 메모제이션을 활용하면 시간복잡도는 O(N)이다.  

재귀적으로 다이나믹 프로그래밍 소스코드를 작성하는 방식을 탑-다운 방식(하향식)이라고 한다.  

--------------------------------------------------------------------------------------------------------------------------------  

DP를 활용한 반복피보나치수열  
기존의 피보나치수열을 반복문을 이용하여 풀이하는 방법  

반복적으로 다이나믹 프로그래밍 소스코드를 작성하는 방식을 바텀-업 방식(상향식)이라고 한다.

--------------------------------------------------------------------------------------------------------------------------------  

1로 만들기  
정수 X가 주어질 때 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지이다.  
1. X가 5로 나누어떨어지면, 5로 나눈다.
2. X가 3으로 나누어떨어지면, 3으로 나눈다.
3. X가 2로 나누어떨어지면, 2로 나눈다.
4. X에서 1을 뺀다.  
정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.  

입력형식  
첫째 줄에 정수 X가 주어진다.(1 <= X <= 30_000)  
출력형식  
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.  

입력예제  
26  
출력예제  
3  

키워드 : DP를 이용하여 1로 만드는 횟수를 처음부터 저장하고 저장된 값을 이용하여 현재 값을 1로 만드는 횟수를 저장한다.  
반복문을 이용하여 2부터 시작해서 X값 까지 반복하면서 1로 만드는 횟수를 저장해야 한다.  
1. 배열의 이전 인덱스에는 1로 만드는 최소횟수가 저장되어 있다.
2. 배열의 이전 인덱스 값에 +1을 한다. => 현재 값에서 1을 뺀 연산을 한번 했기 때문에 이전 인덱스 값에 +1을 한것이다.
3. 현재 값이 2로 나눠 떨어지면 현재 인덱스를 2로 나눈 값에 +1을 한다.
=> ex) 현재 값이 8이라면 4는 8에서 2로 나눈 연산을 한번 했기 때문이다.
4. 1을 뺀 연산을 한 결과와 2로 나눈 연산을 한 결과를 비교하여 더 작은 값을 저장한다.  
=> 연산 횟수의 최솟값을 구해야 하므로 1을 뺀 연산과 나눈 연산 중 연산을 더 적게 하는 경우를 저장해야 하기 때문이다.
5. 3으로 나눠 떨어지는 경우와 5로 나눠 떨어지는 경우도 위와 마찬가지로 비교하면서 저장한다.  

이처럼 X까지 반복하면 이전의 값을 이용하여 1로 만드는 최소 횟수를 저장할 수 있다.  

이 문제의 점화식은 아래와 같다.  
![img_2.png](img_2.png)  
+1은 이전의 값들의 최소횟수에서 4가지 방식의 연산 중 한 가지를 했기 때문에 1을 더해준 것이다.
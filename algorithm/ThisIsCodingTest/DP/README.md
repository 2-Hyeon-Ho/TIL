다이나믹 프로그래밍(Dynamic Programming) DP : 메모리 공간을 약간 더 사용하면서 연산 속도를 비약적으로 증가시킬 수 있는 방법  
DP를 사용할 수 있는 경우  
1. 큰 문제를 작은 문제로 나눌 수 있다.  
2. 작은 문제에서 구한 정답은 그것을 포함한 큰 문제에서도 동일하다. 

대표문제 : 피보나치 수열  

메모제이션 기법 : 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로. 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면   
메모한 결과를 그대로 가져오는 기법  => 탑다운 방식에 국한되어 있다.  

다이나믹 프로그래밍의 전형적인 형태는 바텀-업 방식이다.

--------------------------------------------------------------------------------------------------------------------------------  

DP를 활용한 재귀피보나치수열  
기존의 피보나치수열을 재귀함수를 이용하여 풀이할 때는 동일한 함수가 반복적으로 호출되어 시간복잡도가 증가되었다.   
![img.png](img.png)  
위의 그림처럼 중복된 노드를 방문하게 되어 효율적이지 못하다.  
시간복잡도는 O(2^N)이다.

메모제이션 기법을 활용하여 풀이를 하면 이미 구했던 답을 저장해두고 필요하면 다시 쓸 수 있기 때문에 시간복잡도를 줄일 수 있다.  
![img_1.png](img_1.png)  
이와 같이 메모제이션을 활용하면 시간복잡도는 O(N)이다.  

재귀적으로 다이나믹 프로그래밍 소스코드를 작성하는 방식을 탑-다운 방식(하향식)이라고 한다.  

--------------------------------------------------------------------------------------------------------------------------------  

DP를 활용한 반복피보나치수열  
기존의 피보나치수열을 반복문을 이용하여 풀이하는 방법  

반복적으로 다이나믹 프로그래밍 소스코드를 작성하는 방식을 바텀-업 방식(상향식)이라고 한다.

--------------------------------------------------------------------------------------------------------------------------------  

1로 만들기  
정수 X가 주어질 때 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지이다.  
1. X가 5로 나누어떨어지면, 5로 나눈다.
2. X가 3으로 나누어떨어지면, 3으로 나눈다.
3. X가 2로 나누어떨어지면, 2로 나눈다.
4. X에서 1을 뺀다.  
정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.  

입력형식  
첫째 줄에 정수 X가 주어진다.(1 <= X <= 30_000)  
출력형식  
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.  

입력예제  
26  
출력예제  
3  

키워드 : DP를 이용하여 1로 만드는 횟수를 처음부터 저장하고 저장된 값을 이용하여 현재 값을 1로 만드는 횟수를 저장한다.  
반복문을 이용하여 2부터 시작해서 X값 까지 반복하면서 1로 만드는 횟수를 저장해야 한다.  
1. 배열의 이전 인덱스에는 1로 만드는 최소횟수가 저장되어 있다.
2. 배열의 이전 인덱스 값에 +1을 한다. => 현재 값에서 1을 뺀 연산을 한번 했기 때문에 이전 인덱스 값에 +1을 한것이다.
3. 현재 값이 2로 나눠 떨어지면 현재 인덱스를 2로 나눈 값에 +1을 한다.
=> ex) 현재 값이 8이라면 4는 8에서 2로 나눈 연산을 한번 했기 때문이다.
4. 1을 뺀 연산을 한 결과와 2로 나눈 연산을 한 결과를 비교하여 더 작은 값을 저장한다.  
=> 연산 횟수의 최솟값을 구해야 하므로 1을 뺀 연산과 나눈 연산 중 연산을 더 적게 하는 경우를 저장해야 하기 때문이다.
5. 3으로 나눠 떨어지는 경우와 5로 나눠 떨어지는 경우도 위와 마찬가지로 비교하면서 저장한다.  

이처럼 X까지 반복하면 이전의 값을 이용하여 1로 만드는 최소 횟수를 저장할 수 있다.  

이 문제의 점화식은 아래와 같다.  
![img_2.png](img_2.png)  
+1은 이전의 값들의 최소횟수에서 4가지 방식의 연산 중 한 가지를 했기 때문에 1을 더해준 것이다.

--------------------------------------------------------------------------------------------------------------------------------  

개미전사  
메뚜기 정찰병들은 일직선상에 존재하는 식량창고 중에서 서로 인접한 식량창고가 공격받으면 바로 알아챌 수 있다. 따라서 개미 전사가 정찰병에게  
들키지 않고 식량창고를 약탈하기 위해서는 최소한 한 칸 이상 떨어진 식량창고를 약탈해야 한다. 예를 들어 식량창고 4개가 다음과 같이 존재한다고 가정하자.  
{1, 3, 1, 5}  
이때 개미 전사는 두 번째 식량창고와 네 번째 식량창고를 선택했을 때 최댓값인 총 8개의 식량을 빼앗을 수 있다. 개미 전사는 식량 창고가 이렇게 일직선상일 때  
최대한 많은 식량을 얻기를 원한다. 개미 전사를 위해 식량창고 N개의 정보가 주어졌을 때 얻을 수 있는 식량의 최댓값을 구하는 프로그램을 작성하시오.  

입력형식  
첫째 줄에 식량창고의 개수 N이 주어진다.(3 <= N <= 100)  
둘째 줄에 공백으로 구분되어 각 식량창고에 저장된 식량의 개수 K가 주어진다.(0 <= K <= 1_000)  
출력형식  
첫째 줄에 개미 전사가 얻을 수 있는 식량의 최댓값을 출력하시오.  

입력예제  
4  
출력예제  
1 3 1 5  

키워드 : DP를 이용하여 풀이가 가능하다. 최대의 식량을 갯수를 저장하는 배열을 하나 더 생성하여 왼쪽부터 차례대로 식량창고를 턴다고 가정하고  
점화식을 세워 풀이할 수 있다. 

최대 식량갯수를 저장하는 배열은 0번째에는 식량창고의 0번째의 값을 그대로 가져와야 하고 1번째 인덱스는 식량창고의 0번째와 1번째 중 큰값을 저장한다.  
ex) 3 1 1 5 로 식량창고가 채워져 있을 경우  
0번째 인덱스 + 3번째 인덱스가 1번째 인덱스 + 3번째 인덱스 보다 크다. 이럴 경우 두칸을 건너띄고 더하는게 더 큰 수를 얻을 수 있다.  
이렇게 0번째와 1번째 인덱스를 저장하고 2번째 인덱스 부터는 점화식을 이용하여 바텀업 방식의 반복문을 통해 구할 수 있다.  
![img_3.png](img_3.png)  
a(i-1)은 최대의 식량 갯수 배열의 바로 앞의 인덱스이다. 바로 앞의 인덱스를 선택할 경우 현재 인덱스의 식량창고는 선택할 수 없으므로 a(i-1)만 고르고  
a(i-2)는 최대의 식량 갯수 배열의 두단계 앞의 인덱스이다. 이 경우는 현재 인덱스의 식량창고를 선택할 수 있으므로 a(i-1) + K(i)를 저장한다.  
둘 중 큰값을 저장하면 최대의 식량 갯수 배열은 현재 인덱스에서 얻을 수 있는 최대의 식량 값을 저장해 나갈 수 있다.  
제일 마지막 인덱스의 값을 출력하면 약탈 할 수 있는 최대의 식량갯수를 얻을 수 있다.

--------------------------------------------------------------------------------------------------------------------------------  

바닥공사  
가로의 길이가 N, 세로의 길이가 2인 직사각형 형태의 얇은 바닥이 있다. 태일이는 이 얇은 바닥을 1 x 2의 덮개, 2 x 1의 덮개, 2 x 2의 덮개를 이용해 채우고자 한다.  
![img_4.png](img_4.png)  
이때 바닥을 채우는 모든 경우의 수를 구하는 프로그램을 작성하시오. 예를 들어 2 x 3 크기의 바닥을 채우는 경우의 수는 5가지이다.  

입력형식  
첫째 줄에 N이 주어진다. (1 <= N <= 1_000)  
출력형식  
첫째 줄에 2 x N 크기의 바닥을 채우는 방법의 수를 796_796으로 나눈 나머지를 출력한다.  

입력예제  
3  
출력예제  
5  

키워드 : DP를 이용해서 푸는 기초예제 중 하나인 타일링 문제 유형이다. 다이나믹 프로그래밍 문제에서는 종종 결과를 어떤 수로 나눈 결과를 출력하라는  
내용이 들어가 있는 경우가 많다. => 이때는 DP를 이용해서 풀어볼 것을 시도한다.  

DP를 이용해서 풀어야 한다면 점화식을 세워야한다. 왼쪽부터 덮개를 채우는 경우를 생각한다.  
한칸을 채워야 한다면 2 x 1 덮개 하나를 채우는 경우밖에 없다.  
두칸을 채워야 한다면 1 x 2 덮개 두개를 채우는 경우와 2 x 2 덮개 하나를 채우는 경우 총 2가지가 있다.  
이를 이용해 점화식을 세운다면 a(i) = a(i-1) + 2 * a(i-2)로 표현하고 i를 증가 시켜나가며 i에 맞는 경우의 수를 저장한다.  

--------------------------------------------------------------------------------------------------------------------------------  

효율적인 화폐 구성  
N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다. 이때 각 화폐는 몇 개라도 사용할 수 있으며,  
사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다. 예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이  
가장 최소한의 화폐 개수이다.  

입력형식  
첫째 줄에 N, M이 주어진다.(1 <= N <= 100, 1 <= M <= 10_000)  
이후 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐 가치는 10_000보다 작거나 같은 자연수이다.  
출력형식  
첫째 줄에 M원을 만들기 위한 최소한의 화폐 개수를 출력한다.  
불가능할 때는 -1을 출력한다.  

입력예제1  
2 15  
2  
3  
출력예제1  
5  
입력예제2  
3 4  
3  
5  
7  
출력예제2  
-1  

키워드 : 화폐 단위에서 큰 단위가 작은 단위의 배수가 아니라면 그리디로 풀 수 없으므로 DP를 이용하여 풀이할 수 있다.  
적은 금액부터 큰 금액을 확인하면서 최소한의 화폐 개수를 찾아나가야 한다. 화폐로 구성할 수 있는 경우 값을 비교하여 더 작은 값을 저장한다.  
![img_5.png](img_5.png)  
점화식을 세운다면 위의 식으로 세울 수 있다.  

1. 일단 원하는 가격 M+1 크기의 배열을 생성한다.  
2. 배열을 10_001로 채운다.   
=> 주어진 범위에서 최대의 화폐 개수가 10_000이므로 그것보다 크게 설정했다. 최솟값을 비교해야 하기 때문이다.  
=> 처음에 -1로 채워서 만들 수 없는 구성이라면 바로 -1을 출력하려고 했지만 min을 저장하려고 하면 -1이 더 작아서 -1이 저장되는 오류를 범했다.  
3. 첫번째 배열은 0으로 채워줘야 한다. 0을 구성할 수 있는 경우는 0가지이기 때문이다.
4. 금액을 주어진 화폐로 구성할 수 있는 경우(현재금액 - 화폐단위 != 10001)  
=> 현재금액 - 화폐단위가 10_001이 아니라면 이미 구성할 수 있는 금액에서 화폐단위에서 화폐단위만 더하는 것이기 때문에 구성할 수 있는 경우이다.    
5. 배열에 이미 저장된 값과 배열(현재금액 - 화폐단위) + 1 한 값 중 더 작은 값을 저장한다.
6. 원하는 M까지 모두 경우의 수를 저장했으므로 인덱스 M에 해당하는 값이 10_001이면 -1을 아니라면 인덱스 M에 해당하는 값을 출력한다. 



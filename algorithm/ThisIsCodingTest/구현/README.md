구현 알고리즘 : 완전탐색, 시뮬레이션을 모두 구현 알고리즘이라고 본다.

=> 완전 탐색 : 모든 경우의 수를 주저없이 다 계산하는 해결 방법   
=> 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행하는 방법

------------------------------------------------------------------------------------------------------------------

4-1번 상하좌우  
N x N 크기의 정사각형에서 가장 왼쪽,위의 좌표는 (1,1)이다. 탐험가는 항상 (1,1)에서 출발한다. 상하좌우로 입력 받은 문자에
따라 움직이며 정사각형 범위밖으로 나가는 입력은 무시된다. 이때 최종적으로 도착하는 좌표를 구하여라.  
키워드 : 연산횟수는 이동횟수에 비례한다.

이동횟수가 N번인 경우 시간복잡도는 O(N)이다.

------------------------------------------------------------------------------------------------------------------

4-2번 시각  
정수 N이 입력되면 00시00분00초부터 N시59분59초까지 모든 시각중에서 3이 하나라도 포함된 경우의 수를 구하여라.  
키워드 : 모든 시간은 총 86,400개로 정해져 있기 때문에 완전 탐색으로 경우의 수를 구할 수 있다.

◎주의할 점 : 완전 탐색 알고리즘은 가능한 경우의 수를 모두 검색해보는 탐색방법이다. 일반적으로 완전 탐색 알고리즘은 비효율적인
시간복잡도를 가지고 있기 때문에 데이터의 갯수가 클 경우에는 정상적으로 동작하지 않을 수 있다.  
탐색해야할 데이터의 갯수가 100만개 이하일 경우에 사용하는 것이 좋다.

------------------------------------------------------------------------------------------------------------------

4-3번 왕실의 나이트  
8 x 8 체스판에서 나이트가 하나있다. 나이트의 이동할 수 있는 경우는 총 두가지 일때 입력된 위치에서 나이트가 체스판을 벗어나지
않고 이동할 수 있는 경우의 수를 구하여라.
1. 수평으로 두칸 이동한 후 수직으로 한칸 이동
2. 수평으로 한칸 이동한 후 수직으로 두칸 이동  
   키워드 : 나이트가 이동할 수 있는 경우를 변수로 만들어서 관리하면 해결할 수 있다.

앞선 상하좌우 문제와 비슷한 문제이다. 상하좌우 문제에서는 dx, dy라는 리스트를 이용해 이동방향을 기록했었다.  
이 문제에서는 xRoute, yRoute로 대신하였다. 둘 다 자주 사용되는 방법이니 참고해야한다.

------------------------------------------------------------------------------------------------------------------

4-4번 게임개발
정수 N, M을 입력받고 N x M 크기의 맵을 생성한다. 각각의 칸은 바다(1), 육지(0)이다. 캐릭터의 처음 위치는 A, B를 입력받아
(A, B)위치에 생성한다. 첫 위치는 육지에만 생성할 수 있다. d를 입력받아 캐릭터가 처음에 바라보고 있는 방향을 설정한다.
북(0), 동(1), 남(2), 서(3) 다음으로 N x M 크기의 맵에 바다 또는 육지를 설정하도록 입력받는다. 캐릭터는 상하좌우로 움질일 수
있으며, 바다로는 이동할 수 없고 움직임 매뉴얼은 아래와 같다. 이때 방문한 칸의 수를 구하여라.
1. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 갈 곳을 정한다.
2. 바로 왼쪽에 아직 가보지 않은 칸이라면 왼쪽으로 회전하고 한칸 전진한다. 왼쪽에 가본 칸이라면 왼쪽으로 회전만하고 1번으로 간다.
3. 네 방향 모두 가본칸이거나 바다인 경우 바라보는 기준으로 한칸 뒤로간 후 1번으로 간다. 이때 뒤칸이 바다인 경우 멈춘다.  
   키워드 : 일반적으로 방향을 설정해서 이동하는 문제 유형은 dx, dy라는 별도의 리스트를 만든 후 방향을 정하는 것이 효과적이다.  
   바라보고 있는 방향 d에 맞게 dx,dy방향으로 이동한다.

전형적인 시뮬레이션 문제로써 별도의 알고리즘이 필요한것 보다 문제에서 요구하는 요구사항을 오류없이 구현하면 된다.   
⭐️자주 출제되는 이동문제이므로 반복풀이 해보는 것이 중요하다⭐️  
이 문제에서는 바라보고 있는 방향 d가 북(0),동(1),남(2),서(2)이므로 dx, dy의 순서도 {북, 동, 남, 서}로 만들어야 한다.  
=> 보고 있는 방향에 맞게 이동하려면 dx[d] dy[d]로 관리하는게 효율적이기 때문이다. 
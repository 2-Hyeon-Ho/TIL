정렬이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것이다. 정렬을 통해 이진 탐색을 할 수 있다.  

선택정렬(Selection Sort) : 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복한다.  
![img.png](img.png)  
⭐️주의할점 ⭐   
제일 마지막의 숫자는 비교할 필요가 없이 무조건 제일 큰 수 이므로 데이터 수 - 1 까지만 반복한다.  
선택정렬은 n-1번 만큼 가장 작은 수를 찾아서 맨 앞으로 보낸다. 시간 복잡도는 O(N^2)이다. 데이터가 많을 경우 속도가 느리므로 비효율적이다.  

------------------------------------------------------------------------------------------------------------------------

삽입정렬(Insertion Sort) : 특정한 데이터를 적절한 위치에 삽입한다.  
![img_1.png](img_1.png)  
⭐️주의할점 ⭐  
첫번째 원소는 정렬되어 있다고 생각하기 때문에 인덱스 1부터 반복한다. 비교할 값을 한 칸씩 왼쪽으로 이동해가며 비교하므로 1까지 줄어들도록  
반복해야 0번째 인덱스와 1번째 인덱스를 비교한다. 0까지 줄어들면서 반복하면 ArrayIndexOutOfBoundsException가 발생한다.  
삽입정렬의 시간 복잡도는 O(N^2)인데 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작한다. 최선의 시간 복잡도는 O(N)이다.  

------------------------------------------------------------------------------------------------------------------------

퀵정렬(Quick Sort) : 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.  
기준(pivot)을 선택하는 방법에는 왼쪽 기준, 오른쪽 기준, 중앙 기준이 있다. 주로 많이 다루는 왼쪽 기준으로 피벗을 설정하였다.  
![img_2.png](img_2.png)  
⭐️주의할점 ⭐  
피벗을 기준으로 왼쪽과 오른쪽에서 탐색을 진행해 풀이 방법에 맞게 반복문을 진행한다. left <= end && array[pivot] >= array[left] 이와 같은  
반복문을 실행한다. left <= end 조건을 array[pivot] >= array[left] 조건보다 먼저 두지 않으면 마지막 비교할 때 left의 값이 배열크기의 값보다  
커지므로 ArrayIndexOutOfBoundsException가 발생할 수 있다. 그러므로 left <= end 조건을 먼저 비교해 while문을 탈출한다.  
그리고 left <= right 조건이 불충족 될 경우는 분할이 된 경우이므로 분할된 기준으로 왼쪽과 오른쪽 데이터에 대해서 퀵정렬을 재귀호출 한다.  
이때 왼쪽 데이터 정렬은 0부터 분할데이터 -1 까지 정렬을 계속해서 진행하고 오른쪽 데이터 정렬은 분할데이터 +1부터 데이터크기(n)까지 정렬을 한다.  
최종 탈출 조건은 리스트의 데이터 개수가 1개인 경우 탈출한다. 즉, 이미 정렬이 되어 있는것이므로 분할이 불가능하여 탈출하고 return하여 다음 재귀문을 호출한다.  



최단경로 알고리즘은 말 그대로 가장 짧은 경로를 찾는 알고리즘이다. 최단 경로 문제는 보통 그래프를 이용해 표현하는데 각 지점은 '노드'로 표현되고,  
지점간 연결된 도로는 그래프에서 '간선'으로 표현된다. 보통 최단 경로를 모두 출력하는 문제보다는 단순히 최단거리를 출력하도록 요구하는 문제가 많이 출제된다.  

최단거리 알고리즘의 대표적인 예는 다익스트라 최단경로, 플로이드 워셜, 벨만 포드 알고리즘 이렇게 3가지이다.  
최단경로 알고리즘에는 그리디 알고리즘과 다이나믹 프로그래밍 알고리즘이 적용된다.  

----------------------------------------------------------------------------------------------------------------------  

다익스트라 최단 경로 알고리즘 : 그래프에서 여러 개의 노드가 있을 때 특정한 노드에서 출발하여 다른 노드로 가는 최단 경로를 구해주는 알고리즘이다.  
기본적으로 그리디 알고리즘으로 분류된다. 매번 '가장 비용이 적은 노드'를 선택해서 임의의 과정을 반복하기 때문이다.  

동작원리  
1. 출발 노드를 설정한다.
2. 최단 거리 테이블을 초기화한다.
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.
5. 위 과정에서 3번과 4번을 반복한다.  

초기상태에 모든 노드로 가는 최단 거리를 '무한'으로 초기화 한다. 출발하는 노드(1번)의 거리는 0으로 설정한다.  
![img.png](img.png)   
![img_1.png](img_1.png)   

1번 노드를 거쳐 다른 노드로 가는 비용을 계산한다. 즉, 연결된 모든 간선을 하나씩 확인한다.  
현재 1번 노드까지 오는 비용은 0이므로 연결된 노드의 간선길이에 0을 더한 값이 노드로 가는 비용이다.
![img_2.png](img_2.png)   

이후 모든 단계에서 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택해야 한다. 현재는 4번노드의 거리가 1로 가장 짧으므로 4번노드가 선택된다.  
4번 노드까지 오는 비용은 1이므로 연결된 노드의 간선길이에 1을 더한 값이 노드로 가는 비용이다. 기존의 거리보다 4번 노드를 거쳐 가는 비용이 더 적을 경우 갱신한다.  
![img_3.png](img_3.png)   

방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드는 2번과 5번 노드인데 보통 숫자가 작은 노드부터 탐색하므로 2번 노드를 선택한다.  
2번 노드까지 오는 비용은 2이므로 연결된 노드 3번까지 거리 3 + 2 = 5 인데 기존의 3번노드 까지 거리는 4였으므로 갱신하지 않는다.  
연결된 4번 노드도 마찬가지로 4번까지 거리 2 + 2 = 4인데 기존의 4번노드 까지 거리는 1이므로 갱신하지 않는다.  
![img_4.png](img_4.png)  
![img_5.png](img_5.png)   

마찬가지로 다음 노드로 5번으로 이동하여 연결된 노드에 대해 비용을 갱신할 수 있다면 갱신한다.  
![img_6.png](img_6.png)   

이후 3번 노드도 동일한 과정을 반복한다.  
![img_7.png](img_7.png)   

마지막으로 6번 노드도 동일한 과정을 반복하고 최종 최단 거리 테이블은 다음과 같다.  
![img_8.png](img_8.png)   

1번 노드로부터 출발했을 때 2번,3번,4번,5번,6번 노드까지 가기 위한 최단 경로가 각각 2,3,1,2,4라는 의미이다.  

다익스트라 알고리즘이 진행되면서 한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것이다.

간단한 다익스트라 알고리즘  
O(V^2)의 시간 복잡도를 가지며 V는 노드의 개수를 의미한다. 처음에 각 노드에 대한 최단 거리를 담는 1차원 리스트를 선언한다.  
이후에 단계마다 '방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택'하기 위해 매 단계마다 1차원 리스트의 모든 원소를 탐색한다.  

입력예제  
6 11  
1  
1 2 2  
1 3 5  
1 4 1  
2 3 3  
2 4 2  
3 2 3  
3 6 5  
4 3 3  
4 5 1  
5 3 1  
5 6 2  
출력예제  
0 2 3 1 2 4  

키워드 : 노드의 인덱스와 거리를 저장하기 위한 객체 Node를 생성한다. 각 노드에 연결되어 있는 노드에 대한 정보를 담기 위해 graph를 선언한다.  
graph는 ArrayList<ArrayList<Node>>로 생성하고 방문한 노드를 체크하는 boolean배열과 노드간 거리를 저장할 distance배열을 생성한다.  
초기 상태의 distance는 infinity로 초기화한다. graph를 노드개수+1 크기로 초기화하고 주어진 노드간의 연결 정보를 graph에 저장한다.  
시작 위치에서 연결된 노드들에 대해 입력받은 거리를 distance배열에 저장한다.  
시작노드를 제외한 노드들을 반복하면서 방문하지 않고 거리가 가장 짧은 노드로 이동한고 방문처리한다.  
기존의 distance에 저장된 거리보다 연결된 노드를 거쳐서 이동하는 거리가 더 짧을 경우 갱신하여 distance에 저장한다.  
반복문을 모두 마쳤을 때 distance배열에 최종 최단 거리가 저장되어 있으므로 출력할 수 있다.  

간단한 다익스트라 알고리즘은 최단 거리가 가장 짧은 노드를 매번 선형 탐색해야 하므로 시간 복잡도가 O(V^2)이다.  
전체 노드의 개수가 5_000개 이하라면 일반적으로 이 코드로 풀 수 있지만 노드의 개수가 10_000개를 넘어가는 문제라면 이 코드로 문제를 해결하기 어렵다.  

----------------------------------------------------------------------------------------------------------------------  

개선된 다익스트라 알고리즘 : 힙 자료구조를 사용하여 특정 노드까지의 최단 거리에 대한 정보를 힙에 담아서 처리하므로 출발 노드로 부터  
가장 거리가 짧은 노드를 더욱 빠르게 찾을 수 있다.  

동작원리  
다익스트라 알고리즘이 동작하는 기본원리는 전의 방법과 같고 현재 가장 가까운 노드를 저장하기 위한 목적으로만 우선순위 큐를 추가로 이용한다.  

초기상태에 모든 노드로 가는 최단 거리를 '무한'으로 초기화 한다. 출발하는 노드(1번)의 거리는 0으로 설정한다.
이후에 우선순위 큐에 1번 노드를 넣는다.  
![img_9.png](img_9.png)  
![img_10.png](img_10.png)  

우선순위 큐를 이용하고 있으므로 거리가 가장 짧은 노드를 선택하기 위해서는 우선순위 큐에서 그냥 노드를 꺼내면 된다.  
우선순위 큐에서 노드를 꺼낸 뒤에 해당 노드를 이미 처리한 적이 있다면 무시하면 되고 아직 처리하지 않은 노드에 대해서만 처리하면 된다.  
우선순위 큐에서 원소를 꺼내면 (0, 1)이 나온다. 이는 1번 노드까지 가는 최단 거리가 0이라는 의미이므로, 1번 노드를 거쳐서 연결된 2,3,4번 노드로 
가는 최소비용을 계산한다. 차례대로 (0+2), (0+5), (0+1)이다. 기존에 2,3,4번 노드로 가는 비용이 무한이었는데 더 짧은 경로를 찾았으므로 갱신한다.  
이렇게 더 짧은 경로를 찾은 노드 정보들은 다시 우선순위 큐에 넣는다.  
![img_11.png](img_11.png)  

이어서 다시 우선순위 큐에서 원소를 꺼내서 동일한 과정을 반복한다. (1,4)의 값을 갖는 원소가 추출되고 최단거리를 계산하여 기존의 값들보다 작다면 
갱신하고 우선순위 큐에 갱신된 노드의 정보들을 넣는다.  
![img_12.png](img_12.png)  

다시 우선순위 큐에서 원소를 꺼내면 (2,2)의 값을 갖는 원소가 추출되고 더 짧은 거리가 있다면 갱신하고 우선순위 큐에 삽입한다.  
하지만 더 짧은 거리가 없기 때문에 값이 갱신되지 않고 큐에 노드의 정보를 삽입하지 않는다.  
![img_13.png](img_13.png)  

우선순위 큐에서 (2,5)의 원소가 추출되고 동일한 과정을 반복한다.  
![img_14.png](img_14.png)  

우선순위 큐에서 (3,3)의 원소가 추출되고 동일한 과정을 반복한다.  
![img_15.png](img_15.png)  

다음으로 우선순위 큐에서 (4,3)의 원소가 추출되는데 3번 노드는 이미 처리된 적이 있다. 그러므로 무시한다.  
![img_16.png](img_16.png)  

우선순위 큐에서 (4,6)의 원소가 추출되고 동일한 과정을 반복한다.  
![img_17.png](img_17.png)  

마지막으로 남은 원소를 꺼내면 (5,3)의 원소가 추출되는데 3번 노드는 이전에 처리된 적이 있으므로  무시한다. 큐가 비었다면 최종 최단 거리 테이블은 다음과 같다.  
![img_18.png](img_18.png)  

개선된 다익스트라 알고리즘  
최악의 경우에도 시간 복잡도 O(ElogV)를 보장한다. V는 노드의 개수이고, E는 간선의 개수이다.    
우선순위 큐를 이용하여 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 방식을 택한 것이다.  

입력예제  
6 11  
1  
1 2 2  
1 3 5  
1 4 1  
2 3 3  
2 4 2  
3 2 3  
3 6 5  
4 3 3  
4 5 1  
5 3 1  
5 6 2  
출력예제  
0 2 3 1 2 4  

키워드 : 인덱스와 거리를 필드로 갖는 Node클래스를 만들고 Comparable 인터페이스를 구현하여 compareTo메서드를 거리가 짧은 것이 높은 우선순위를 갖도록 설정한다.  
기존의 다익스트라 알고리즘에서 선언한 것과 같이 각 노드에 연결되어 있는 노드에 대한 정보를 담기 위해 graph를 선언한다.  
초기 상태의 distance는 infinity로 초기화한다. graph를 노드개수+1 크기로 초기화하고 주어진 노드간의 연결 정보를 graph에 저장한다.  
시작 위치에서 연결된 노드들에 대해 입력받은 거리를 distance배열에 저장한다.  
우선순위 큐에 시작점과 거리를 0으로 하는 원소를 넣고 거리 리스트에 시작점의 거리를 0으로 저장한다.  
우선순위 큐가 비어있을 때까지 반복하며 우선순위 큐에서 원소를 꺼내 최단거리가 가장 짧은 노드를 구한다.  
우선순위 큐에서 꺼낸 원소의 거리가 거리 리스트에 저장된 값보다 크다면 이미 처리된 노드이므로 무시한다.(continue한다.)  
현재 노드와 연결된 모든 노드들을 확인하면서 기존의 distance에 저장된 거리보다 연결된 노드를 거쳐서 이동하는 거리가 더 짧을 경우  
갱신하여 distance에 저장하고 우선순위 큐에 노드의 정보를 삽입한다.  

![img_19.png](img_19.png)

----------------------------------------------------------------------------------------------------------------------  

플로이드 워셜 알고리즘 : '모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우'에 사용할 수 있는 알고리즘이다.  
다익스트라 알고리즘은 '한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우'에 사용하는 알고리즘으로 차이점이 분명하다.  
플로이드 워셜 알고리즘은 노드의 개수가 N이라고 할 때, N번 만큼의 단계를 반복하며 점화식에 맞게 2차원 리스트를 갱신하기 때문에 다이나믹 프로그래밍으로 볼 수 있다. 

동작원리  
각 단계에서 해당 노드를 거쳐 가는 경우를 고려하여 최단 거리 테이블을 갱신한다.  
예를 들어 1번 노드에 대해서 확인 할 때는 1번 노드를 중간에 거쳐 지나가는 모든 경우를 고려하면 된다.  
A노드 -> 1번 노드 -> B노드 이런식으로 기존의 거리보다 1번 노드를 거쳐서 가는 것이 더 짧을 때 테이블을 갱신한다.  
![img_23.png](img_23.png)

초기상태에 2차원 테이블을 모두 무한으로 초기화 하고 자기 자신으로 가는 비용은 0으로 초기화 한다. 즉 (1,1)(2,2)...는 0이다.  
다음으로 주어진 간선간의 거리 정보를 테이블에 초기화 한다.  
![img_20.png](img_20.png)  

처음에 1번 노드를 거쳐 가는 경우를 고려한다. 이 때는 1번 노드를 제외한 2,3,4번 노드 중에 2개의 노드를 선택하므로 총 6가지의 경우가 나온다.  
D23, D24, D32, D34, D42, D43 이렇게 6가지 경우에 기존의 거리보다 1번 노드를 거쳐서 가는 거리가 짧다면 테이블을 갱신한다.  
예를 들어 D23 = min(D23, D21 + D13)인데 기존의 D23은 7이었고 D21 + D13 = 3 + 무한 = 무한 이므로 갱신되지 않는다.  
D24 = min(D24, D21 + D14)인데 기존의 D24 = 무한이었고 D21 + D14 = 3 + 6 = 9이므로 D24는 9로 갱신된다.  
![img_21.png](img_21.png)  

마찬가지로 2번 노드를 거쳐 가는 경우에도 똑같이 동작한다.  
![img_22.png](img_22.png)

3번 노드에 대해서도 동일한 과정을 반복한다.  
![img_24.png](img_24.png)  

4번 노드에 대해서도 동일한 과정을 반복한다. 최종 결과가 테이블에 저장되고 각 지점으로 가는 모든 경로의 최단 경로가 저장됐다.  
![img_25.png](img_25.png)

플로이드 워셜 알고리즘  
N개의 노드 일 때 N번의 단계를 수행하며, 단계마다 현재 노드를 거쳐 가는 모든 경로를 고려하여 탐색하기 때문에  
단계마다 O(N^2)의 시간 복잡도를 가지고 총 시간 복잡도는 O(N^3)이다.  

입력예제  
4 7  
1 2 4  
1 4 6  
2 1 3  
2 3 7  
3 1 5  
3 4 4  
4 3 2  
출력예제  
0 4 8 6  
3 0 7 9  
5 9 0 4  
7 11 2 0  

키워드 : 거리에 대한 정보를 저장할 2차원 배열을 생성하고 초기에 무한으로 초기화한 후 자기 자신으로 가는 거리는 0으로 저장한다.  
주어진 간선간의 거리 정보를 테이블에 입력하고 점화식에 맞게 플로이드 워셜 알고리즘을 수행한다.  
이후 3중 for문을 이용하여 i번째 노드를 탐색할 때 ji + ik가 기존의 거리보다 작을 경우 최단거리 리스트를 갱신한다.  
각 노드간의 최단거리를 2차원 배열을 출력해서 구할 수 있다.

----------------------------------------------------------------------------------------------------------------------  

미래도시  
공중 미래 도시에는 1번부터 N번 까지의 회사가 있는데 특정 회사끼리는 서로 도로를 통해 연결되어 있다. 방문 판매원 A는 현재 1번 회사에 위치해 있으며,  
X번 회사에 방문해 물건을 판매하고자 한다. 연결된 2개의 회사는 양방향으로 이동할 수 있다. 공중 미래 도시에서의 도로는 정확히 1만큼의 시간으로 이동할 수 있다. 
또한 오늘 방문 판매원 A는 기대하던 소개팅에도 참석하고자 한다. 소개팅의 상대는 K번 회사에 존재한다. 방문 판매원 A는 X번 회사에 가서 물건을  
판매하기 전에 먼저 소개팅 상대의 회사에 찾아가서 함께 커피를 마실 예정이다. 따라서 방문 판매원 A는 1번 회사에서 출발하여 K번 회사를 방문한 뒤에  
X번 회사로 가는 것이 목표다. 이때 방문 판매원 A는 가능한 한 빠르게 이동하고자 한다. 방문 판매원이 회사 사이를 이동하게 되는 최소시간을 구하여라.  

입력형식  
첫째 줄에 전체 회사의 개수 N과 경로의 개수 M이 공백으로 구분되어 차례대로 주어진다. (1 <= N,M <= 100)  
둘째 줄부터 M+1번째 줄에는 연결된 두 회사의 번호가 공백으로 구분되어 주어진다.  
M+2번째 줄에는 X와 K가 공백으로 구분되어 차례대로 주어진다.(1 <= K <= 100)  
출력형식  
첫째 줄에 방문 판매원 A가 K번 회사를 거쳐 X번 회사로 가는 최소 이동 시간을 출력한다.  
만약 X번 회사에 도달할 수 없다면 -1을 출력한다.  

입력예제1    
5 7  
1 2  
1 3  
1 4  
2 4  
3 4  
3 5  
4 5  
4 5  
출력예제1  
3  

입력예제2  
4 2  
1 3  
2 4  
3 4  
출력예제2  
-1  

키워드 : 전형적인 플로이드 워셜 알고리즘 문제이다. N의 범위가 100이하로 매우 한정적이므로 구현이 간단한 플로이드 워셜 알고리즘으로 풀이한다.  
문제의 핵심은 1번 노드에서 X를 거쳐 K로 가는 최단거리는 1번 노드에서 X까지의 최단거리 + X번 노드에서 K까지의 최단거리이다.  
기존의 플로이드 워셜 알고리즘 풀이대로 작성하고 1번 노드에서 X노드까지 거리 + X번 노드에서 K노드까지 거리를 구하여 출력한다.  
K번 노드까지 갈 수 없는 경우 -1을 출력해야 하므로 결과가 INFINITY보다 크거나 같을 경우 -1을 출력한다. 
결과가 INFINITY와 같을 경우에만 -1을 출력한다면 INFINITY+INFINITY의 경우에는 만족하지 못하므로 크거나 같을 경우로 설정한다.

----------------------------------------------------------------------------------------------------------------------  

전보  
어떤 나라에는 N개의 도시가 있다. 그리고 각 도시는 보내고자 하는 메시지가 있는 경우, 다른 도시로 전보를 보내서 다른 도시로 해당 메시지를 전송할  
수 있다. 하지만 X라는 도시에서 Y라는 도시로 전보를 보내고자 한다면, 도시 X에서 Y로 향하는 통로가 설치되어 있어야 한다. 예를 들어 X에서 Y로 향하는  
통로는 있지만, Y에서 X로 향하는 통로가 없다면 Y는 X로 메시지를 보낼 수 없다. 또한 통로를 거쳐 메시지를 보낼 때는 일정 시간이 소요된다.  
어느 날 C도시에서 위급 상황이 발생했다. 그래서 최대한 많은 도시로 메시지를 보내고자 한다. 메시지는 도시 C에서 출발하여 각 도시 사이에 설치된 통로를 거쳐  
최대한 많이 퍼져나갈 것이다. 각 도시의 번호와 통로가 설치되어 있는 정보가 주어졌을 때, 도시 C에서 보낸 메시지를 받게 되는 도시의 개수는 총 몇개이며  
도시들이 모두 메시지를 받는 데까지 걸리는 시간은 얼마인지 계산하는 프로그램을 작성하시오.  

입력형식  
첫째 줄에 도시의 개수 N, 통로의 개수 M, 메시지를 보내고자 하는 도시 C가 주어진다. (1 <= N <= 30_000, 1 <= M <= 200_000, 1 <= C <= N)  
둘째 줄부터 M+1번째 줄에 걸쳐서 통로에 대한 정보 X,Y,Z가 주어진다. 이는 특정 도시 X에서 다른 특정 도시 Y로 이어지는 통로가 있으며, 메시지가 전달되는  
시간이 Z라는 의미다. (1 <= X,Y <= N, 1 <= Z <= 1_000)  
출력형식  
첫째 줄에 도시 C에서 보낸 메시지를 받는 도시의 총 개수와 총 걸리는 시간을 공백으로 구분하여 출력한다.  

입력예제  
3 2 1  
1 2 4  
1 3 2  
출력예제  
2 4  

키워드 : 다익스트라 알고리즘을 이용해서 풀 수 있다. N과 M의 범위가 충분히 크기 때문에 우선순위 큐를 이용하여 다익스트라 알고리즘을 작성한다.  
시간 테이블을 무한으로 초기화 하고 각 도시에 연결되어 있는 도시에 대한 정보를 담는 graph를 만들고 모든 간선의 정보를 입력한다.  
우선순위 큐를 생성하고 시작점인 C도시에 시간을 0으로 설정하고 우선순위 큐에 삽입한다. 그 후 최단경로 리스트에 C의 값을 0으로 초기화 한다.  
우선순위 큐가 비어졌을 때까지 반복하고 우선순위 큐는 시간이 짧은 순서로 우선순위가 부여되므로 우선순위 큐에서 시간이 가장 짧은 도시에 대한 정보를 꺼낸다.  
이미 처리한 도시정보에 대해서는 무시한다.(continue) 현재 도시에 대해 연결된 도시들을 순회하며 기존의 시간보다 현재 도시를 거쳐 가는 시간이  
더 적을 경우 시간 테이블을 갱신한 후 우선순위 큐에 도시정보를 삽입한다. 우선순위 큐에서 모든 원소를 꺼냈을 때 최단 시간 리스트가 저장된다.  
메시지를 받는 도시의 총 개수는 시간 테이블에서 시간이 무한이 아니라면 C에서 출발해 메세지를 받을 수 있다는 뜻이므로 시간이 INFINITY가 아니어야 한다.  
또한 자기 자신의 도시는 제외해야 하므로 시간이 0이 아니고 무한이 아닐 경우의 도시의 수를 카운트하면 된다.  
총 걸리는 시간은 시간 테이블에서 무한인 시간을 제외하고 가장 큰 시간을 출력하면 된다.